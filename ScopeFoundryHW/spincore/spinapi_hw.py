"""
Created on Mar 21, 2022

@author: bened
"""
from ScopeFoundry.hardware import HardwareComponent

from spinapi.spinapi import (
    pb_core_clock,
    pb_set_debug,
    pb_init,
    pb_get_error,
    pb_close,
    pb_inst_pbonly, pb_start_programming, PULSE_PROGRAM, pb_stop_programming,
    pb_start, Inst,
)


    
from ctypes import c_uint, c_double, c_int


def errorCatcher(statusVar):
    if statusVar < 0:
        print("pulse_blaster Error: ", pb_get_error())


class PulseBlasterHW(HardwareComponent):

    name = "pulse_blaster"

    def setup(self):
        S = self.settings
        S.New("debug", int, initial=1)
        S.New("clock_frequency", initial=500, unit="MHz", description='inherit to specific board')
        S.New('I', int, initial=0, description='is the bit number of the PulseBlaster channel connected to the I (or "in phase") input of the SRS microwave signal generator.')
        S.New('Q', int, initial=1, description='is the bit number of the PulseBlaster channel connected to the Q (or "in quadrature") input of the SRS microwave signal generator.')
        S.New('STARTtrig', int, initial=3, description='is the bit number of the PulseBlaster channel used to generate the pulses fed to the Data Acquisition Card (DAQ) to trigger the start of data aquisition at each experiment scan point.')
        S.New('DAQ', int, initial=4, description='is the bit number of the PulseBlaster channel used to generate the pulses fed to the DAQ to gate/act as a sample clock to time the data aquisition.')
        S.New('AOM', int, initial=4, description='is the bit number of the PulseBlaster channel connected to the TTL input of the switch used to switch on and off the radio-frequency drive to the Acousto Optic Modulator (AOM).')
        S.New('uW', int, initial=5, description='is the bit number of the PulseBlaster channel connected to the TTL input of the switch used to switch on and off the microwaves generated by the SRS microwave signal generator.')

    def connect(self):

        pb_set_debug(1)
        status = pb_init()
        errorCatcher(status)
        S = self.settings
        S.clock_frequency.connect_to_hardware(write_func=pb_core_clock)
        pb_core_clock(S["clock_frequency"])

    def disconnect(self):
        pb_close()

    def configurePB(self):
        return
    
        # self.connect()

    def pb_inst_pbonly(self, flags, inst, inst_data, length):
        flags = c_uint(flags)
        inst = c_int(inst)
        inst_data = c_int(inst_data)
        length = c_double(length)
        return pb_inst_pbonly(flags, inst, inst_data, length)
        
    def program_hw(self, instructionArray):
        status = pb_start_programming(PULSE_PROGRAM)
        errorCatcher(status)
        startDone = False
        start = [0]
        print('programSequence instructionArray', instructionArray)
        for i in range(0, len(instructionArray)):
            if startDone:
                status = pb_inst_pbonly(instructionArray[i][0], instructionArray[i][1], instructionArray[i][2], instructionArray[i][3])
                errorCatcher(status)
            else:
                start[0] = pb_inst_pbonly(instructionArray[0][0], instructionArray[0][1], instructionArray[0][2], instructionArray[0][3])
                errorCatcher(start[0])
                startDone = True
            print('programSequence instruction', instructionArray[i])

        status = pb_stop_programming()
        errorCatcher(status)
        status = pb_start()
        errorCatcher(status)
        status = pb_close()
        errorCatcher(status)
        return instructionArray
    
    def get_register_addresses_dict(self, include=["I", "Q", "STARTtrig", 'DAQ', 'AOM', 'uW']):
        addresses = {}
        # renamed MW --> uW           
        for i in include:
            addresses[i] = 2 ** self.settings[i]
            
        print('get_register_addresses_dict', addresses)
        return addresses
    
    def get_channels_dict(self, include=["I", "Q", "STARTtrig", 'DAQ', 'AOM', 'uW']):
        channels = {}
        for i in include:
            channels[i] = self.settings[i]
        return channels
    
    def get_channel_names(self, include=["I", "Q", "STARTtrig", 'DAQ', 'AOM', 'uW']):
        return {v:k for k,v in self.get_channel_names(include)}
        
