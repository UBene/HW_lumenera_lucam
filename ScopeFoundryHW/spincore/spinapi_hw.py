"""
Created on Mar 21, 2022

@author: bened
"""
from ScopeFoundry.hardware import HardwareComponent

from spinapi.spinapi import (
    pb_core_clock,
    pb_set_debug,
    pb_init,
    pb_get_error,
    pb_close,
    pb_inst_pbonly, pb_start_programming, PULSE_PROGRAM, pb_stop_programming,
    pb_start, Inst,
)
    
from ctypes import c_uint, c_double, c_int


def catch_error(status):
    if status < 0:
        print("pulse_blaster Error: ", pb_get_error())


class PulseBlasterHW(HardwareComponent):

    name = "pulse_blaster"

    def setup(self):
        S = self.settings
        S.New("debug", int, initial=1, choices=(('ON', 1), ('OFF', 0)), description='Enable debug log. When enabled, spinapi will generate a file called log.txt, which contains some debugging information')
        S.New("clock_frequency", initial=500, unit="MHz", description='inherit to specific board - see manual')
        S.New('I', int, initial=4, description='PulseBlaster channel connected to the I (or "in phase") input of the SRS microwave signal generator.')
        S.New('Q', int, initial=5, description='PulseBlaster channel connected to the Q (or "in quadrature") input of the SRS microwave signal generator.')
        S.New('STARTtrig', int, initial=0, description='PulseBlaster channel used to generate the pulses fed to the Data Acquisition Card (DAQ) to trigger the start of data aquisition at each experiment scan point.')
        S.New('DAQ', int, initial=1, description='PulseBlaster channel used to generate the pulses fed to the DAQ to gate/act as a sample clock to time the data aquisition.')
        S.New('AOM', int, initial=2, description='PulseBlaster channel connected to the TTL input of the switch used to switch on and off the radio-frequency drive to the Acousto Optic Modulator (AOM).')
        S.New('uW', int, initial=3, description='PulseBlaster channel connected to the TTL input of the switch used to switch on and off the microwaves generated by the SRS microwave signal generator.')
        S.New('error', str, ro=True)

    def catch_error(self, status):
        if status < 0:
            error = pb_get_error()
            self.settings['error'] = error
            print("pulse_blaster Error: ", error)

    def connect(self):

        self.catch_error(pb_init())
        S = self.settings
        S.clock_frequency.connect_to_hardware(write_func=self.write_core_clock)
        S.debug.connect_to_hardware(write_func=self.write_debug)
        
    def write_core_clock(self):
        self.catch_error(pb_core_clock())

    def write_debug(self):
        self.catch_error(pb_set_debug())
        
    def write_init(self):
        self.catch_error(pb_init())
            
    def disconnect(self):
        pb_close()
        
    def configure(self):
        pb_close()
        pb_set_debug(1)
        self.write_init()
        S = self.settings
        pb_core_clock(S["clock_frequency"])

    def pb_inst_pbonly(self, flags, inst, inst_data, length):
        #flags = c_uint(flags)
        #inst = c_int(inst)
        #inst_data = c_int(inst_data)
        #length = c_double(length)
        self.catch_error(pb_inst_pbonly(flags, inst, inst_data, length))
        
    def write_pulse_program(self, instructionArray):
        status = pb_start_programming(PULSE_PROGRAM)
        self.catch_error(status)
        startDone = False
        start = [0]
        print('programSequence instructionArray', instructionArray)
        for i in range(0, len(instructionArray)):
            if startDone:
                self.pb_inst_pbonly(instructionArray[i][0], instructionArray[i][1], instructionArray[i][2], instructionArray[i][3])
            else:
                self.pb_inst_pbonly(instructionArray[0][0], instructionArray[0][1], instructionArray[0][2], instructionArray[0][3])
                self.catch_error(start[0])
                startDone = True
            print('programSequence instruction', instructionArray[i])

        self.stop_programming()
        self.start()
        self.close()
        return instructionArray
        
    def program_hw(self, instructionArray):
        try:
            self.write_pulse_program(instructionArray)
        except:
            status = pb_start_programming(PULSE_PROGRAM)
            self.catch_error(status)
            startDone = False
            start = [0]
            print('programSequence instructionArray', instructionArray)
            for i in range(0, len(instructionArray)):
                if startDone:
                    status = pb_inst_pbonly(instructionArray[i][0], instructionArray[i][1], instructionArray[i][2], instructionArray[i][3])
                    self.catch_error(status)
                else:
                    start[0] = pb_inst_pbonly(instructionArray[0][0], instructionArray[0][1], instructionArray[0][2], instructionArray[0][3])
                    self.catch_error(start[0])
                    startDone = True
                print('programSequence instruction', instructionArray[i])
            
        status = pb_stop_programming()
        self.catch_error(status)
        status = pb_start()
        self.catch_error(status)
        status = pb_close()
        self.catch_error(status)
        return instructionArray
    
    def stop_programming(self):
        self.catch_error(pb_stop_programming())
    
    def start(self):
        self.catch_error(pb_start())
    
    def close(self):
        self.catch_error(pb_close())
    
    def get_register_addresses_dict(self, include=["I", "Q", "STARTtrig", 'DAQ', 'AOM', 'uW']):
        addresses = {}
        for i in include:
            addresses[i] = 2 ** self.settings[i]            
        return addresses
    
    def get_channels_dict(self, include=["I", "Q", "STARTtrig", 'DAQ', 'AOM', 'uW']):
        channels = {}
        for i in include:
            channels.update({i:self.settings[i]})
        return channels
    
    def get_channel_names(self, include=["I", "Q", "STARTtrig", 'DAQ', 'AOM', 'uW']):
        d = self.get_channels_dict(include)
        return {v:k for k, v in d.items()}
        
