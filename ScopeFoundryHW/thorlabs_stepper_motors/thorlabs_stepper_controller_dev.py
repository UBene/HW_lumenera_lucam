import time
import logging
import ctypes
from ctypes import byref, c_int, c_uint16, c_uint32
from threading import Lock

logger = logging.getLogger(__name__)


_ERRORS = {
    ## FTDI and Communication errors
    
    # The following errors are generated from the FTDI communications module or supporting code. 
    0: ("FT_OK", "Success"),
    1: ("FT_InvalidHandle","The FTDI functions have not been initialized."),
    2: ("FT_DeviceNotFound", "The Device could not be found: This can be generated if the function TLI_BuildDeviceList() has not been called."),  
    3: ("FT_DeviceNotOpened","The Device must be opened before it can be accessed. See the appropriate Open function for your device."),  
    4: ("FT_IOError", "An I/O Error has occured in the FTDI chip."),
    5: ("FT_InsufficientResources" , "There are Insufficient resources to run this application."),
    6: ("FT_InvalidParameter" , "An invalid parameter has been supplied to the device."), 
    7: ("FT_DeviceNotPresent" , """The Device is no longer present. The device may have been disconnected since the last TLI_BuildDeviceList() call."""),  
    8: ("FT_IncorrectDevice" , "The device detected does not match that expected"),
    # The following errors are generated by the device libraries. 
    16: ("FT_NoDLLLoaded", "The library for this device could not be found"),  
#     17 (0x11) FT_NoFunctionsAvailable - No functions available for this device./term>  
#     18 (0x12) FT_FunctionNotAvailable - The function is not available for this device./term>  
#     19 (0x13) FT_BadFunctionPointer - Bad function pointer detected./term>  
#     20 (0x14) FT_GenericFunctionFail - The function failed to complete succesfully./term>  
#     21 (0x15) FT_SpecificFunctionFail - The function failed to complete succesfully./term>  

    ## General DLL control errors
    
    #The following errors are general errors generated by all DLLs. 
    
    # 32 (0x20) TL_ALREADY_OPEN - Attempt to open a device that was already open.  
    # 33 (0x21) TL_NO_RESPONSE - The device has stopped responding.  
    # 34 (0x22) TL_NOT_IMPLEMENTED - This function has not been implemented.  
    # 35 (0x23) TL_FAULT_REPORTED - The device has reported a fault.  
    # 36 (0x24) TL_INVALID_OPERATION - The function could not be completed at this time.  
    # 36 (0x28) TL_DISCONNECTING - The function could not be completed because the device is disconnected.  
    # 41 (0x29) TL_FIRMWARE_BUG - The firmware has thrown an error  
    # 42 (0x2A) TL_INITIALIZATION_FAILURE - The device has failed to initialize  
    # 43 (0x2B) TL_INVALID_CHANNEL - An Invalid channel address was supplied  
    
    
    ## Motor specific errors
    # 
    # The following errors are motor specific errors generated by the Motor DLLs. 
    # 
    # 37 (0x25) TL_UNHOMED - The device cannot perform this function until it has been Homed.  
    # 38 (0x26) TL_INVALID_POSITION - The function cannot be performed as it would result in an illegal position.  
    # 39 (0x27) TL_INVALID_VELOCITY_PARAMETER - An invalid velocity parameter was supplied
    #  The velocity must be greater than zero.  
    # 44 (0x2C) TL_CANNOT_HOME_DEVICE - This device does not support Homing 
    #  Check the Limit switch parameters are correct.  
    # 45 (0x2D) TL_JOG_CONTINOUS_MODE - An invalid jog mode was supplied for the jog function.  
    # 46 (0x2E) TL_NO_MOTOR_INFO - There is no Motor Parameters available to convert Real World Units.  

    }

def _err(retval):
    if retval == 0:
        return retval
    else:
        err_name, description = _ERRORS.get(retval, ("UNKNOWN", "Unknown error code."))
        raise IOError("Thorlabs Kinesis Error [{}] {}: {} ".format(retval, err_name, description))

class ThorlabsStepperControllerDev(object):
    
    " Use Thorlabs kinesis software to control Stepper motor controllers"
    
    
    def __init__(self, dev_num=0, serial_num=None, debug=False):
        """
        serial_num if defined should be a string or integer
        """
        
        #self.poll_time = poll_time # polling period in seconds
        
        self.debug = debug
        if self.debug:
            logger.debug("ThorlabsStepperControllerDev.__init__")
            
        logger.setLevel('DEBUG')
        
        # Load DLL libraries, note DeviceManager.dll must be loaded first    
        D = self.devman_dll = ctypes.windll.LoadLibrary("C:\Program Files\Thorlabs\Kinesis\Thorlabs.MotionControl.DeviceManager.dll")
        S = self.sbc_dll = ctypes.windll.LoadLibrary("C:\Program Files\Thorlabs\Kinesis\Thorlabs.MotionControl.Benchtop.StepperMotor.dll")

        _err(D.TLI_BuildDeviceList())
        serialNos = ctypes.create_string_buffer(100)
        _err(D.TLI_GetDeviceListByTypeExt(serialNos, 100, 70))
        
            
        # byte arrays for the serial numbers
        self._serial_numbers = [x for x in serialNos.value.split(b',') if x]
        print(self._serial_numbers)

        if debug:
            logger.debug("serial_numbers available {} --> {}".format(serialNos.value, self._serial_numbers))
            logger.debug("serial_number requested {}".format(repr(serial_num)))

        
        # _id is byte string representing serial number, like b'37874816'
        
        if serial_num:
            self._id = str(serial_num).encode() # _id must be a bytes array
            if debug:
                logger.debug("using serial number {}".format(self._id))
        else:
            if debug:
                logger.debug("using device number {}".format(dev_num))
            self._id = self._serial_numbers[dev_num]

        #self._sernum = str(self.sernum).encode('ascii') 
        
        self.lock = Lock()

        if self.debug:
            logger.debug("SBC_Open: {}".format( self._id))
        
        with self.lock:
            _err(S.SBC_Open(self._id))
            self.num_chans = S.SBC_GetNumChannels(self._id)
        
        # polling required to update device status, otherwise must use request functions before reads
        #self.sbc_dll.SBC_StartPolling(self._id, 100 )
        
        #time.sleep(0.2)
    
    
    def close(self):
        _err(self.sbc_dll.SBC_Close(self._id))
    
    def get_serial_num(self):
        return self._id.decode()
        
    
    def stop_immediate(self, chan):
        with self.lock:
            _err(self.sbc_dll.SBC_StopImmediate(self._id, chan))
             
    def stop_profiled(self, chan):
        with self.lock:
            _err(self.sbc_dll.SBC_StopProfiled(self._id, chan))
        
    def read_position(self, chan):
        with self.lock:
            _err(self.sbc_dll.SBC_RequestPosition(self._id,chan))
            pos = self.sbc_dll.SBC_GetPosition(self._id,chan)
        return pos
    
    
    def write_chan_enable(self, chan, enable=True):
        print("write_chan_enable", chan, enable)
        if enable:
            with self.lock: _err(self.sbc_dll.SBC_EnableChannel(self._id, chan))
        else:
            with self.lock: _err(self.sbc_dll.SBC_DisableChannel(self._id, chan))
            
    def write_move_to_position(self, chan, pos):
        """
        Move the device to the specified position (index). 
        Returns immediately (non-blocking)
        motor will move until position is reached, or stopped
        pos is an integer in device units (microsteps)
        """
        if self.debug:
            logger.debug("write_move_to_position chan {} --> {}".format(chan,pos) )
        with self.lock:
            _err(self.sbc_dll.SBC_MoveToPosition(self._id, chan, int(pos)))
        
    def move_and_wait(self, chan,pos, timeout=10):
        self.write_move_to_position(chan, pos)
        t0 = time.time()
        while(self.read_position(chan) != pos):
            time.sleep(0.1)
            if (time.time() - t0) > timeout:
                self.stop_profiled(chan)
                raise( IOError("Failed to move"))
    
    def start_home(self, chan):
        """
        Homing the device will set the device to a known state and determine the home position,
        Returns immediately (non-blocking)
        motor will home until position is reached, or stopped
        will be in position 0 when done
        """
        with self.lock:
            _err(self.sbc_dll.SBC_Home(self._id, chan))
            
                
    def home_and_wait(self, chan, timeout=100):
        self.start_home(chan)
        t0 = time.time()
        while(self.read_position(chan) != 0):
            time.sleep(0.1)
            if (time.time() - t0) > timeout:
                self.stop_profiled(chan)
                raise( IOError("Failed to home"))
            
            
    def read_velocity(self,chan):
        return self.read_velocity_params(chan)[1]

    def read_acceleration(self,chan):
        return self.read_velocity_params(chan)[0]

    def read_velocity_params(self, chan):
        """SBC_GetVelParams  ( char const *  serialNo,  
          short  channel,  
          int *  acceleration,  
          int *  maxVelocity  
         ) 
        """
       
        acc = c_int()
        vel = c_int()

        with self.lock:
            _err(self.sbc_dll.SBC_RequestVelParams(self._id, chan))
            _err(self.sbc_dll.SBC_GetVelParams(self._id, chan, byref(acc), byref(vel)))
        
        return acc.value, vel.value
    
    def write_velocity_params(self, chan, acc, vel):
        with self.lock:
            _err(self.sbc_dll.SBC_SetVelParams(self._id, chan, int(acc), int(vel)))

    def read_homing_velocity(self, chan):
        with self.lock:
            _err(self.sbc_dll.SBC_RequestHomingParams(self._id, chan))
            vel = self.sbc_dll.SBC_GetHomingVelocity(self._id, chan)
        return vel

    def write_homing_velocity(self, chan, vel):
        with self.lock:
            _err(self.sbc_dll.SBC_SetHomingVelocity(self._id, chan, int(vel)))
        
        
    def read_message_queue(self, chan):
        """returns a list of messages and clears the queue,
        may be empty if no messages are available"""
        messages = []
        messageType = c_uint16()
        messageID = c_uint16()
        messageData = c_uint32()
        
        message_type_names = {
            0: "GenericDevice",
            1: "GenericPiezo",  
            2: "GenericMotor", 
            3: "GenericDCMotor",  
            4: "GenericSimpleMotor", 
            5: "RackDevice" ,
            6: "Laser",
            7: "TECCtlr",  
            8: "Quad", 
            9: "NanoTrak",  
            10:"Specialized",  
            11:"Solenoid"}

        
        with self.lock:
            #self.sbc_dll.SBC_RequestStatu
            
            num_messages = self.sbc_dll.SBC_MessageQueueSize(self._id, chan)
            #print(num_messages)
            for i in range(num_messages):
                success = self.sbc_dll.SBC_GetNextMessage(
                                        self._id, chan,
                                        byref(messageType), byref(messageID), byref(messageData))
        
                message = (message_type_names[messageType.value],
                           messageID.value, messageData.value)
                messages.append(message)
                
            self.sbc_dll.SBC_ClearMessageQueue(self._id, chan)
        
        print(messages)
        return messages
        