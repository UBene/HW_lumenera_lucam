import time
import logging
import ctypes
from threading import Lock

logger = logging.getLogger(__name__)


_ERRORS = {
    # FTDI and Communication errors

    # The following errors are generated from the FTDI communications module
    # or supporting code.
    0: ("FT_OK", "Success"),
    1: ("FT_InvalidHandle", "The FTDI functions have not been initialized."),
    2: ("FT_DeviceNotFound", "The Device could not be found: This can be generated if the function TLI_BuildDeviceList() has not been called."),
    3: ("FT_DeviceNotOpened", "The Device must be opened before it can be accessed. See the appropriate Open function for your device."),
    4: ("FT_IOError", "An I/O Error has occured in the FTDI chip."),
    5: ("FT_InsufficientResources", "There are Insufficient resources to run this application."),
    6: ("FT_InvalidParameter", "An invalid parameter has been supplied to the device."),
    7: ("FT_DeviceNotPresent", """The Device is no longer present. The device may have been disconnected since the last TLI_BuildDeviceList() call."""),
    8: ("FT_IncorrectDevice", "The device detected does not match that expected"),
    # The following errors are generated by the device libraries.
    16: ("FT_NoDLLLoaded", "The library for this device could not be found"),
    #     17 (0x11) FT_NoFunctionsAvailable - No functions available for this device./term>
    #     18 (0x12) FT_FunctionNotAvailable - The function is not available for this device./term>
    #     19 (0x13) FT_BadFunctionPointer - Bad function pointer detected./term>
    #     20 (0x14) FT_GenericFunctionFail - The function failed to complete succesfully./term>
    # 21 (0x15) FT_SpecificFunctionFail - The function failed to complete
    # succesfully./term>

    # General DLL control errors

    # The following errors are general errors generated by all DLLs.

    # 32 (0x20) TL_ALREADY_OPEN - Attempt to open a device that was already open.
    # 33 (0x21) TL_NO_RESPONSE - The device has stopped responding.
    # 34 (0x22) TL_NOT_IMPLEMENTED - This function has not been implemented.
    # 35 (0x23) TL_FAULT_REPORTED - The device has reported a fault.
    # 36 (0x24) TL_INVALID_OPERATION - The function could not be completed at this time.
    # 36 (0x28) TL_DISCONNECTING - The function could not be completed because the device is disconnected.
    # 41 (0x29) TL_FIRMWARE_BUG - The firmware has thrown an error
    # 42 (0x2A) TL_INITIALIZATION_FAILURE - The device has failed to initialize
    # 43 (0x2B) TL_INVALID_CHANNEL - An Invalid channel address was supplied


    # Motor specific errors
    #
    # The following errors are motor specific errors generated by the Motor DLLs.
    #
    # 37 (0x25) TL_UNHOMED - The device cannot perform this function until it has been Homed.
    # 38 (0x26) TL_INVALID_POSITION - The function cannot be performed as it would result in an illegal position.
    # 39 (0x27) TL_INVALID_VELOCITY_PARAMETER - An invalid velocity parameter was supplied
    #  The velocity must be greater than zero.
    # 44 (0x2C) TL_CANNOT_HOME_DEVICE - This device does not support Homing
    #  Check the Limit switch parameters are correct.
    # 45 (0x2D) TL_JOG_CONTINOUS_MODE - An invalid jog mode was supplied for the jog function.
    # 46 (0x2E) TL_NO_MOTOR_INFO - There is no Motor Parameters available to
    # convert Real World Units.

}

TCUBEDLL = "Thorlabs.MotionControl.TCube.DCServo.dll"
DEVICEMANAGERDLL = "Thorlabs.MotionControl.DeviceManager.dll"
TDC001_ID = 83


def _err(retval):
    if retval == 0:
        return retval
    else:
        err_name, description = _ERRORS.get(
            retval, ("UNKNOWN", "Unknown error code."))
        raise IOError("Thorlabs Kinesis Error [{}] {}: {} ".format(
            retval, err_name, description))


class TDC001DCServoDev(object):

    def __init__(self, kinesis_path=r"C:\Program Files\Thorlabs\Kinesis", dev_num=0, serial_num=None, debug=False):
        """
        serial_num if defined should be a string or integer
        """
        self.debug = debug
        if self.debug:
            logger.debug("ThorlabsStepperControllerDev.__init__")

        logger.setLevel('DEBUG')

        D = ctypes.cdll.LoadLibrary(kinesis_path + "\\" + DEVICEMANAGERDLL)
        S = self.cc_dll = ctypes.windll.LoadLibrary(
            kinesis_path + "\\" + TCUBEDLL)
        _err(D.TLI_BuildDeviceList())
        serialNos = ctypes.create_string_buffer(100)
        _err(D.TLI_GetDeviceListByTypeExt(serialNos, 100, TDC001_ID))

        # byte code serial numbers
        self._serial_numbers = [x for x in serialNos.value.split(b',') if x]
        #
        if debug:
            print(
                "serial_numbers available {} --> {}".format(serialNos.value, self._serial_numbers))
            logger.debug(
                "serial_numbers available {} --> {}".format(serialNos.value, self._serial_numbers))
            logger.debug("serial_number requested {}".format(repr(serial_num)))

        # _id is byte string representing serial number, like b'37874816'
        if serial_num:
            self._id = str(serial_num).encode()  # _id must be a bytes array
            if debug:
                logger.debug("using serial number {}".format(self._id))
        else:
            if debug:
                logger.debug("using device number {}".format(dev_num))
            self._id = self._serial_numbers[dev_num]

        self.lock = Lock()
        if self.debug:
            logger.debug("CC_Open: {}".format(self._id))
        with self.lock:
            _err(S.CC_Open(self._id))

    def close(self):
        _err(self.cc_dll.CC_Close(self._id))

    def get_serial_num(self):
        return self._id.decode()

    def stop_immediate(self):
        with self.lock:
            _err(self.cc_dll.CC_StopImmediate(self._id))

    def stop_profiled(self, chan):
        with self.lock:
            _err(self.cc_dll.CC_StopProfiled(self._id))

    def read_position(self):
        with self.lock:
            _err(self.cc_dll.CC_RequestPosition(self._id))
            index = self.cc_dll.CC_GetPosition(self._id)
        return index

    def write_move_to_position(self, index):
        """
        Move the device to the specified position in (index). 
        Returns immediately (non-blocking)
        motor will move until position is reached, or stopped        
        """
        if self.debug:
            logger.debug(f"write_move_to_position index: {index}")
        with self.lock:
            _err(self.cc_dll.CC_MoveToPosition(self._id, index))

    def move_and_wait(self, pos, timeout=10):
        self.write_move_to_position(pos)
        t0 = time.time()
        while(self.read_position() != pos):
            time.sleep(0.1)
            if (time.time() - t0) > timeout:
                self.stop_profiled()
                raise(IOError("Failed to move"))

    def start_home(self):
        """
        Homing the device will set the device to a known state and determine the home position,
        Returns immediately (non-blocking)
        motor will home until position is reached, or stopped
        will be in position 0 when done
        """
        with self.lock:
            _err(self.cc_dll.CC_Home(self._id))

    def home_and_wait(self, timeout=100):
        self.start_home()
        t0 = time.time()
        while(self.read_position() != 0):
            time.sleep(0.1)
            if (time.time() - t0) > timeout:
                self.stop_profiled()
                raise(IOError("Failed to home"))

    # def read_velocity(self,chan):
    #     return self.read_velocity_params(chan)[1]
    #
    # def read_acceleration(self,chan):
    #     return self.read_velocity_params(chan)[0]
    #
    # def read_velocity_params(self, chan):
    #     """CC_GetVelParams  ( char const *  serialNo,
    #       short  channel,
    #       int *  acceleration,
    #       int *  maxVelocity
    #      )
    #     """
    #
    #     acc = c_int()
    #     vel = c_int()
    #
    #     with self.lock:
    #         _err(self.cc_dll.CC_RequestVelParams(self._id, chan))
    #         _err(self.cc_dll.CC_GetVelParams(self._id, chan, byref(acc), byref(vel)))
    #
    #     return acc.value, vel.value
    #
    # def write_velocity_params(self, chan, acc, vel):
    #     with self.lock:
    #         _err(self.cc_dll.CC_SetVelParams(self._id, chan, int(acc), int(vel)))
    #
    # def read_homing_velocity(self, chan):
    #     with self.lock:
    #         _err(self.cc_dll.CC_RequestHomingParams(self._id, chan))
    #         vel = self.cc_dll.CC_GetHomingVelocity(self._id, chan)
    #     return vel
    #
    # def write_homing_velocity(self, chan, vel):
    #     with self.lock:
    #         _err(self.cc_dll.CC_SetHomingVelocity(self._id, chan, int(vel)))
    #
    #
    # def read_message_queue(self, chan):
    #     """returns a list of messages and clears the queue,
    #     may be empty if no messages are available"""
    #     messages = []
    #     messageType = c_uint16()
    #     messageID = c_uint16()
    #     messageData = c_uint32()
    #
    #     message_type_names = {
    #         0: "GenericDevice",
    #         1: "GenericPiezo",
    #         2: "GenericMotor",
    #         3: "GenericDCMotor",
    #         4: "GenericSimpleMotor",
    #         5: "RackDevice" ,
    #         6: "Laser",
    #         7: "TECCtlr",
    #         8: "Quad",
    #         9: "NanoTrak",
    #         10:"Specialized",
    #         11:"Solenoid"}
    #
    #
    #     with self.lock:
    #         #self.cc_dll.CC_RequestStatu
    #
    #         num_messages = self.cc_dll.CC_MessageQueueSize(self._id, chan)
    #         #print(num_messages)
    #         for i in range(num_messages):
    #             success = self.cc_dll.CC_GetNextMessage(
    #                                     self._id, chan,
    #                                     byref(messageType), byref(messageID), byref(messageData))
    #
    #             message = (message_type_names[messageType.value],
    #                        messageID.value, messageData.value)
    #             messages.append(message)
    #
    #         self.cc_dll.CC_ClearMessageQueue(self._id, chan)
    #
    #     print(messages)
    #     return messages
