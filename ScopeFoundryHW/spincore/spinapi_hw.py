"""
Created on Mar 21, 2022

@author: bened
"""
from enum import Enum

from ScopeFoundry.hardware import HardwareComponent

from spinapi.spinapi import (
    pb_core_clock,
    pb_set_debug,
    pb_init,
    pb_get_error,
    pb_close,
    pb_inst_pbonly, pb_start_programming, PULSE_PROGRAM, pb_stop_programming,
    pb_start,
)
from bokeh.core.property import include

class Inst(Enum):
    CONTINUE = 0    #Not Used
    STOP=1          #Not Used
    LOOP=2          #Number of desired loops
    END_LOOP=3      #Address of instruction originating loop
    JSR=4           #Address of first instruction in subroutine
    RTS=5           #Not Used
    BRANCH=6        #Address of instruction to branch to
    LONG_DELAY=7    #Number of desired repetitions
    WAIT=8          #Not Used
    
from ctypes import c_uint, c_double, c_int
import numpy as np


def errorCatcher(statusVar):
    if statusVar < 0:
        print("Error: ", pb_get_error())


class PulseBlasterHW(HardwareComponent):

    name = "pulse_blaster"

    def setup(self):
        S = self.settings
        S.New("debug", int, initial=1)
        S.New("clock_freq", initial=500, unit="MHz")
        S.New('I', int, initial=0, description='is the bit number of the PulseBlaster channel connected to the I (or "in phase") input of the SRS microwave signal generator.')
        S.New('Q', int, initial=1, description='is the bit number of the PulseBlaster channel connected to the Q (or "in quadrature") input of the SRS microwave signal generator.')
        S.New('STARTtrig', int, initial=3, description='is the bit number of the PulseBlaster channel used to generate the pulses fed to the Data Acquisition Card (DAQ) to trigger the start of data aquisition at each experiment scan point.')
        S.New('DAQ', int, initial=4, description='is the bit number of the PulseBlaster channel used to generate the pulses fed to the DAQ to gate/act as a sample clock to time the data aquisition.')
        S.New('AOM', int, initial=4, description='is the bit number of the PulseBlaster channel connected to the TTL input of the switch used to switch on and off the radio-frequency drive to the Acousto Optic Modulator (AOM).')
        S.New('MW', int, initial=5, description='is the bit number of the PulseBlaster channel connected to the TTL input of the switch used to switch on and off the microwaves generated by the SRS microwave signal generator.')
    def connect(self):

        pb_set_debug(1)
        status = pb_init()
        errorCatcher(status)
        S = self.settings
        S.connect_to_hardware(write_func=pb_core_clock)
        pb_core_clock(S["clock_freq"])

    def disconnect(self):
        pb_close()

    def configurePB(self):
        self.connect()

    def pb_inst_pbonly(self, flags, inst, inst_data, length):
        flags = c_uint(flags)
        inst = c_int(inst)
        inst_data = c_int(inst_data)
        length = c_double(length)
        return pb_inst_pbonly(flags, inst, inst_data, length)

    def programPB(self, sequence, seqCtl, sequenceArgs):
        channels = seqCtl.makeSequence(sequence, sequenceArgs)
        channelBitMasks = seqCtl.sequenceEventCataloguer(channels)
        instructionArray = self.programSequence(channelBitMasks)
        return instructionArray
    
    def programSequence(self, channelBitMasks):
        eventTimes = list(channelBitMasks.keys())
        numEvents = len(eventTimes)
        eventDurations =list(np.zeros(numEvents-1))
        numInstructions = numEvents-1
        for i in range(0,numInstructions):
            if i == numInstructions-1:
                eventDurations[i] = eventTimes[i+1]-eventTimes[i]
            else:
                eventDurations[i] = eventTimes[i+1]-eventTimes[i]
        instructionArray = []
        bitMasks = list(channelBitMasks.values())
        start = [0]
        for i in range(0,numEvents-1):
            if i==(numEvents-2):
                instructionArray.extend([[bitMasks[i], Inst.BRANCH, start[0], eventDurations[i]]])
            else:
                instructionArray.extend([[bitMasks[i], Inst.CONTINUE, 0, eventDurations[i]]])
        
        #Program Pulseblaster
        self.connect()
        status = pb_start_programming(PULSE_PROGRAM)
        errorCatcher(status)
        startDone = False
        for i in range(0, len(instructionArray)):
            if startDone:
                status = pb_inst_pbonly(instructionArray[i][0],instructionArray[i][1],instructionArray[i][2],instructionArray[i][3])
                errorCatcher(status)
            else:
                start[0]= pb_inst_pbonly(instructionArray[0][0],instructionArray[0][1],instructionArray[0][2],instructionArray[0][3])
                errorCatcher(start[0])
                startDone = True
        status = pb_stop_programming()
        errorCatcher(status)
        status = pb_start()
        errorCatcher(status)
        status = pb_close()
        errorCatcher(status)
        return instructionArray
    
    def get_register_addresses_dict(self, include=["I", "Q", "STARTtrig", 'DAQ', 'AOM', 'uW']):
        addresses = {}
        
        # not sure why uW case is special
        # Idea rename setting MW --> uW and delete following special case 
        if 'uW' in include:
            addresses['uW'] = 2**self.settings['MW']
            include.remove('uW')
            
        for i in include:
            addresses[i] = 2**self.settings[i]
        return addresses
            
        
        
        
        