"""
Created on Mar 21, 2022

@author: bened
"""
from ScopeFoundry.hardware import HardwareComponent

from spinapi.spinapi import (
    pb_core_clock,
    pb_set_debug,
    pb_init,
    pb_get_error,
    pb_close,
    pb_inst_pbonly, pb_start_programming, PULSE_PROGRAM, pb_stop_programming,
    pb_start, Inst, pb_get_version
)


class PulseBlasterHW(HardwareComponent):

    name = "pulse_blaster"

    def setup(self):
        S = self.settings
        S.New("debug", int, initial=1, choices=(('ON', 1), ('OFF', 0)), description='Enable debug log. When enabled, spinapi will generate a file called log.txt, which contains some debugging information')
        S.New("clock_frequency", initial=500, unit="MHz", description='inherit to specific board - see manual')
        S.New('last_error', str, ro=True)
        S.New('version', str, ro=True)

        # channels must be of type int!
        S.New('I', int, initial=4, description='PulseBlaster channel connected to the I (or "in phase") input of the SRS microwave signal generator.')
        S.New('Q', int, initial=5, description='PulseBlaster channel connected to the Q (or "in quadrature") input of the SRS microwave signal generator.')
        # S.New('STARTtrig', int, initial=0, description='PulseBlaster channel used to generate the pulses fed to the Data Acquisition Card (DAQ) to trigger the start of data aquisition at each experiment scan point.')
        # S.New('DAQ', int, initial=1, description='PulseBlaster channel used to generate the pulses fed to the DAQ to gate/act as a sample clock to time the data aquisition.')
        S.New('DAQ_sig', int, initial=1, description='PulseBlaster channel used to generate the pulses fed to the DAQ to gate/act to trigger signal.')
        S.New('DAQ_ref', int, initial=0, description='PulseBlaster channel used to generate the pulses fed to the DAQ to gate/act to trigger signal.')
        S.New('AOM', int, initial=2, description='PulseBlaster channel connected to the TTL input of the switch used to switch on and off the radio-frequency drive to the Acousto Optic Modulator (AOM).')
        S.New('uW', int, initial=3, description='PulseBlaster channel connected to the TTL input of the switch used to switch on and off the microwaves generated by the SRS microwave signal generator.')
        S.New('sync_out', int, initial=23, description='Blaster channel to synchronize external clocks, such as uW generator. (Not strictly required for most ODMR experiment)')
        self.channels = [k for k, v in self.settings.as_dict().items() if v.dtype == int]
        
        self.add_operation('configure', self.configure)
        self.add_operation('write close', self.write_close)

    def catch_error(self, status):
        if status == -91:
            print('pulse_blaster not initialize: Connect pulse_blaster')
        if status < 0:
            error = pb_get_error()
            self.settings['last_error'] = error
            print("pulse_blaster last error: ", repr(error), status)
        else:
            self.settings['last_error'] = 'last call ok'

    def connect(self): 
        S = self.settings
        S.clock_frequency.connect_to_hardware(write_func=self.write_core_clock)
        S.debug.connect_to_hardware(write_func=self.write_debug)
        S.version.connect_to_hardware(pb_get_version)
        
        S.debug.write_to_hardware()
        self.write_init()
        S.clock_frequency.write_to_hardware()
                        
    def disconnect(self):
        self.write_close()
                
    def write_core_clock(self, freq):
        pb_core_clock(freq)  # does not return a status integer

    def write_debug(self, debug):
        pb_set_debug(debug)  # does not return a status integer
        
    def write_init(self):
        '''Initializes the board. This must be called before any other functions 
        are used which communicate with the board. 
        If you have multiple boards installed in your system, pb_select_board() 
        may be called first to select which board to initialize.'''
        self.catch_error(pb_init())

    def write_pb_inst_pbonly(self, flags, inst, inst_data, length):
        self.catch_error(pb_inst_pbonly(flags, inst, inst_data, length))
    
    def configure(self):
        self.write_close()
        self.settings.debug.write_to_hardware()
        self.write_init()
        self.settings.clock_frequency.write_to_hardware()
        
    def write_pulse_program_and_start(self, pulse_program):
        self.configure()
        self.start_programming(PULSE_PROGRAM)
        for i in range(len(pulse_program)):
            if self.settings['debug_mode']: 
                print('write_pulse_program instruction', pulse_program[i])
            self.write_pb_inst_pbonly(*pulse_program[i])
        self.stop_programming()
        self.write_start()
        self.write_close()
        return pulse_program
        
    # def program_hw(self, instructionArray):
    #     try:
    #         self.write_pulse_program(instructionArray)
    #     except:
    #         status = pb_start_programming(PULSE_PROGRAM)
    #         self.catch_error(status)
    #         startDone = False
    #         start = [0]
    #         print('programSequence instructionArray', instructionArray)
    #         for i in range(0, len(instructionArray)):
    #             if startDone:
    #                 status = pb_inst_pbonly(instructionArray[i][0], instructionArray[i][1], instructionArray[i][2], instructionArray[i][3])
    #                 self.catch_error(status)
    #             else:
    #                 start[0] = pb_inst_pbonly(instructionArray[0][0], instructionArray[0][1], instructionArray[0][2], instructionArray[0][3])
    #                 self.catch_error(start[0])
    #                 startDone = True
    #             print('programSequence instruction', instructionArray[i])
    #
    #     status = pb_stop_programming()
    #     self.catch_error(status)
    #     status = pb_start()
    #     self.catch_error(status)
    #     status = pb_close()
    #     self.catch_error(status)
    #     return instructionArray
    
    def start_programming(self, target):
        self.catch_error(pb_start_programming(target))
    
    def stop_programming(self):
        self.catch_error(pb_stop_programming())
    
    def write_start(self):
        self.catch_error(pb_start())
    
    def write_close(self):
        '''End communication with the board. This is generally called as the last line in a program. 
        Once this is called, no further communication can take place with the board unless the board 
        is reinitialized with pb_init(). However, any pulse program that is loaded and running at the 
        time of calling this function will continue to run indefinitely.'''
        self.catch_error(pb_close())
    
    def get_flags(self, channel:str) -> int:
        '''
        flags is an integer representing the output state of the pulse blaster.
        
        E.g: flags=5 represents that physical channels 0 and 2 are high and the others low 
            as the binary representation of 5 is 000000000000000000000101
                
        Note:
        - To create the flags to turn on the channels 'A' and 'B' (and all other channels off) use:
            flags_AB = self.get_flags('A') ^ self.get_flags('B')
        
        - To turn channel 'B' low (w/o changing low)
            flags_A = flags_AB ^ self.get_flags('B')
        '''
        return 2 ** self.settings[channel]
    
    @property        
    def flags_lookup(self):
        return {2 ** self.settings[i]:i for i in self.channels}    
        
    @property        
    def rev_flags_lookup(self):
        return {2 ** self.settings[i]:i for i in self.channels}

    @property
    def channels_lookup(self):
        return {i:self.settings[i] for i in self.channels}
    
    @property
    def rev_channels_lookup(self):
        return {self.settings[i]:i for i in self.channels}
        
