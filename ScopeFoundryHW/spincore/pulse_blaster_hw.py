"""
Created on Mar 21, 2022

@author: bened
"""
from ScopeFoundry.hardware import HardwareComponent

from spinapi.spinapi import (
    pb_core_clock,
    pb_set_debug,
    pb_init,
    pb_get_error,
    pb_close,
    pb_inst_pbonly, pb_start_programming, PULSE_PROGRAM, pb_stop_programming,
    pb_start, Inst, pb_get_version
)


class PulseBlasterHW(HardwareComponent):

    name = "pulse_blaster"

    def setup(self):
        S = self.settings
        S.New("debug", int, initial=1, choices=(('ON', 1), ('OFF', 0)), description='Enable debug log. When enabled, spinapi will generate a file called log.txt, which contains some debugging information')
        S.New("clock_frequency", initial=500, unit="MHz", description='inherit to specific board - see manual')
        S.New('I', int, initial=4, description='PulseBlaster channel connected to the I (or "in phase") input of the SRS microwave signal generator.')
        S.New('Q', int, initial=5, description='PulseBlaster channel connected to the Q (or "in quadrature") input of the SRS microwave signal generator.')
        S.New('STARTtrig', int, initial=0, description='PulseBlaster channel used to generate the pulses fed to the Data Acquisition Card (DAQ) to trigger the start of data aquisition at each experiment scan point.')
        S.New('DAQ', int, initial=1, description='PulseBlaster channel used to generate the pulses fed to the DAQ to gate/act as a sample clock to time the data aquisition.')
        S.New('DAQ_sig', int, initial=1, description='PulseBlaster channel used to generate the pulses fed to the DAQ to gate/act to trigger signal.')
        S.New('DAQ_ref', int, initial=0, description='PulseBlaster channel used to generate the pulses fed to the DAQ to gate/act to trigger signal.')
        S.New('AOM', int, initial=2, description='PulseBlaster channel connected to the TTL input of the switch used to switch on and off the radio-frequency drive to the Acousto Optic Modulator (AOM).')
        S.New('uW', int, initial=3, description='PulseBlaster channel connected to the TTL input of the switch used to switch on and off the microwaves generated by the SRS microwave signal generator.')
        S.New('last_error', str, ro=True)
        S.New('version', str, ro=True)
        
        self.channels = ["I", "Q", "STARTtrig", 'DAQ', 'DAQ_sig', 'DAQ_ref', 'AOM', 'uW']

        self.add_operation('configure', self.configure)
        self.add_operation('write close', self.write_close)

    def catch_error(self, status):
        if status < 0:
            error = pb_get_error()
            self.settings['last_error'] = error
            print("pulse_blaster last error: ", repr(error))
        else:
            self.settings['last_error'] = 'last call ok'

    def connect(self): 
        S = self.settings
        S.clock_frequency.connect_to_hardware(write_func=self.write_core_clock)
        S.debug.connect_to_hardware(write_func=self.write_debug)
        S.version.connect_to_hardware(pb_get_version)
        
        S.debug.write_to_hardware()
        self.write_init()
        S.clock_frequency.write_to_hardware()
                        
    def disconnect(self):
        self.write_close()
                
    def write_core_clock(self, freq):
        pb_core_clock(freq)  # does not return a status integer

    def write_debug(self, debug):
        pb_set_debug(debug)  # does not return a status integer
        
    def write_init(self):
        '''Initializes the board. This must be called before any other functions are used which communicate with the board. 
        If you have multiple boards installed in your system, pb_select_board() may be called first to select 
        which board to initialize.'''
        self.catch_error(pb_init())

    def write_pb_inst_pbonly(self, flags, inst, inst_data, length):
        self.catch_error(pb_inst_pbonly(flags, inst, inst_data, length))
    
    def configure(self):
        self.write_close()
        self.settings.debug.write_to_hardware()
        self.write_init()
        self.settings.clock_frequency.write_to_hardware()
        
    def write_pulse_program_and_start(self, pulse_program):
        self.configure()
        print('write_pulse_program 0', pulse_program)

        self.start_programming(PULSE_PROGRAM)
        print('write_pulse_program', pulse_program)
        for i in range(len(pulse_program)):
            self.write_pb_inst_pbonly(*pulse_program[i])
            if self.settings['debug_mode']: 
                print('write_pulse_program instruction', pulse_program[i])
        self.stop_programming()
        self.write_start()
        self.write_close()
        return pulse_program
        
    # def program_hw(self, instructionArray):
    #     try:
    #         self.write_pulse_program(instructionArray)
    #     except:
    #         status = pb_start_programming(PULSE_PROGRAM)
    #         self.catch_error(status)
    #         startDone = False
    #         start = [0]
    #         print('programSequence instructionArray', instructionArray)
    #         for i in range(0, len(instructionArray)):
    #             if startDone:
    #                 status = pb_inst_pbonly(instructionArray[i][0], instructionArray[i][1], instructionArray[i][2], instructionArray[i][3])
    #                 self.catch_error(status)
    #             else:
    #                 start[0] = pb_inst_pbonly(instructionArray[0][0], instructionArray[0][1], instructionArray[0][2], instructionArray[0][3])
    #                 self.catch_error(start[0])
    #                 startDone = True
    #             print('programSequence instruction', instructionArray[i])
    #
    #     status = pb_stop_programming()
    #     self.catch_error(status)
    #     status = pb_start()
    #     self.catch_error(status)
    #     status = pb_close()
    #     self.catch_error(status)
    #     return instructionArray
    
    def start_programming(self, target):
        self.catch_error(pb_start_programming(target))
    
    def stop_programming(self):
        self.catch_error(pb_stop_programming())
    
    def write_start(self):
        self.catch_error(pb_start())
    
    def write_close(self):
        '''End communication with the board. This is generally called as the last line in a program. 
        Once this is called, no further communication can take place with the board unless the board 
        is reinitialized with pb_init(). However, any pulse program that is loaded and running at the 
        time of calling this function will continue to run indefinitely.'''
        self.catch_error(pb_close())
    
    def get_register_addresses_dict(self):
        return {i:2 ** self.settings[i] for i in self.channels}          
    
    def get_channels_dict(self):
        return {i:self.settings[i] for i in self.channels}
    
    def get_channel_names(self):
        return {v:k for k, v in self.get_channels_dict().items()}
        
